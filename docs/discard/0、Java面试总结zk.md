# Java基础

### Java虚拟机的内存结构

程序计数器、Java堆、Java虚拟机栈、本地方法栈、方法区

**JVM内存为什么要分成新生代，老年代，持久代**

### **垃圾收集算法**

GC最基础的算法有三种： 

- 标记 -清除算法、
- 复制算法、
- 标记-整理算法，
- 我们常用的垃圾回收器一般都采用**分代收集算法**。

### 你知道哪些JVM性能调优

- 设定堆内存大小

-Xmx：堆内存最大限制。

- 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代

-XX:NewSize：新生代大小

-XX:NewRatio 新生代和老生代占比

-XX:SurvivorRatio：伊甸园空间和幸存者空间的占比

- 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC

### **垃圾回收器**

- Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
- ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
- Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
- Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法
- CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征

### 队列和栈的区别与怎么实现？

**栈可以用数组实现，**

定义一个数组和一个变量，这个变量保存栈顶的位置。

**栈也可以用链表实现，**

用一个节点表示栈顶元素，整数N记录栈大小。入栈时新节点的下一个节点引用指向原来的栈顶节点，出栈时栈顶元素指向原来栈顶元素的下一个节点。

**队列可以使用数组实现**

与实现栈不同，它需要两个指针，一个指向队头（front），一个指向队尾（rear），这样才能方便地进行入队或出队操作

先是1分钟自我介绍，然后问了两个技术类的问题：

#### 堆和栈的区别

对于c语言来说

- 栈区（stack）—由编译器自动分配释放，存放函数的参数值，局部变量的回值等
- 堆区（heap）—一般由答程序员分配释放，若程序员不释放，程序结束时可能由OS回收
- 总而言之：：栈由系统自动分配，而堆由程序代码控制。

对于Java来说

- 栈内存存的是局部变量
- 堆内存存的是对象，凡是new出来的对象都是放在堆内存的，堆内存有垃圾回收机制。

### C语言声明和定义的区别

-  对于变量来说,定义就是声明.

  例如:  int a;  我们可是说它是定义也可以说它是声明。

-   但是对于函数来说定义和声明完全不是一回事 。

  void   sum（int a，int b）；这是函数的声明   void   sum（int a，int b）    {    } 

​    整体是函数的定义  ，函数的定义没有分号 而且要加上一对花括号 ，里边是函数的实现。

3、然后问为什么选择去苏州，

4、然后就还问了一个关于加班的看法

### Java和C++的区别？

1. 二者都是面向对象的语言，都支持封装、继承和多态。C++ 为了兼容 C 也支持面向过程。
2. Java通过虚拟机实现跨平台，C++依赖特定的平台
3. Java没有指针的概念，c++有，Java对内存的访问更加安全
4. Java有内存管理/垃圾回收机制，c++需要程序员手动释放内存。
5. Java支持单继承，c++支持多继承
6. c++的字符串、字符串数组需要加一个结束符。Java不需要

其他版本：

1. Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。
2. Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。
3. Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。
4. Java 支持自动垃圾回收，而 C++ 需要手动回收。
5. Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。
6. Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。
7. Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。

**JAVA与C的区别**

1、Java是面向对象的语言，c是面向过程的语言

2、Java没有指针，c有指针

3、Java有虚拟机，与C相比更容易跨平台

**StringBuffer and StringBuilder**

StringBuffer 是线程安全的，内部使用 synchronized 进行同步

### final

1、声明数据为常量

- 对于基本数据类型，final使它数值不变
- 对于引用类型，final使它的引用不变，也就是不能再指向其他的对象，但被引用的对象本身是可以修改的

2、final可以声明方法不能被子类重写

3、final可以声明类不允许被继承

### static

1、静态变量：类变量，是类的所有实例共有的，可以通过类名调用

2、静态方法：类方法

3、静态代码块

4、静态内部类：静态内部类不能访问外部类的非静态的变量和方法。

### equals()与==

- 对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。
- 对于引用类型，== 判断两个对象的地址是否相同，而 equals() 判断引用的对象是的内容是否相同。

### equals()与hashcode()

https://blog.csdn.net/Mrs_chens/article/details/92761868

**相同点：**

hashCode()方法和equals()方法的作用类似，在Java里都是用来对比两个对象内容是否一致。

**不同点：**

- equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。
- hashCode()相等的两个对象他们的equals()不一定相等，也就是hashCode()不是绝对可靠的。
- hashCode()方法效率高，equals()方法最可靠

### 浅拷贝和深拷贝

浅拷贝和深拷贝都是只针对引用数据类型的。

**浅拷贝：**只复制指向某个对象的引用，而不复制对象本身。新旧对象共享同一块内存。

**深拷贝：**另外创建一个一模一样的对象，新对象跟原对象不共享内存。修改新对象，不会影响到原对象。

### 抽象类与接口的区别

1. 接口体现的是一种规范，抽象类体现的是模板式设计。
2. 一个类可以实现多个接口，但只能继承一个抽象类（接口可以多继承，抽象类只能单继承）。
3. 接口里只能有抽象方法，抽象类里面可以有非抽象方法。

1. 接口里不可以有构造函数和初始化块，抽象类里可以有

1. 接口里不可以定义静态方法，抽象类里可以。
2. 接口里的变量全部为静态常量，抽象类里可以有普通变量

https://www.bilibili.com/read/cv3749315/

- 接口是抽象类的变体，接口中的所有方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。 
- 接口可以多继承，抽象类不行。 
- 接口定义方法，不能实现，而抽象类可以实现部分方法。 
- 接口中基本数据类型为static，而抽象类不是。 
- 接口中不能含有静态代码块以及静态方法，而抽象类可以含有静态方法和静态代码块。

从语法层面来说，

１、抽象类可以提供成员方法的实现细节，而接口中只能存在抽象方法

２、抽象类中成员变量可以是多种类型，接口中成员变量必须用public，static，final修饰

３、一个类只能继承一个抽象类，但可以实现多个接口

４、抽象类中允许含有静态代码块和静态方法，接口不能

从设计层面而言

1.抽象类是对整一个类的属性，行为等方面进行抽象，而接口则是对行为抽象。就好比飞机和鸟，抽象类抽象出的是飞行物类。而接口则是抽闲出飞行方法。

2.**抽象类是一个模板式的设计**，当在开发过程中出现需求更改的情况，只需要更改抽象类而不需要更改它的子类。**接口是一种辐射性设计**，当接口的内容发生改变时，需要同时对实现它的子类进行相应的修改。

3.抽象类可以类比为模板，而接口可以类比为协议

**什么是抽象类？**

由abstract修饰的方法叫抽象方法；由abstract修饰的类叫抽象类。

抽象的类无法进行实例化，因为他不是具体存在的类，或者说这样的类还不够完善，不能直接使用new关键字调用其构造器生成该类的对象。

**什么是接口？**

接口就是一个规范，类似于硬件上面的接口。

接口也弥补了Java单一继承的弱点，也就是类可以实现多个接口。

我们使用interface关键字定义接口。

**抽象类必须要有抽象方法吗？**

- 抽象类可以没有抽象方法
- 声明为抽象类的类不能被实例化，只能被继承。
- 如果一个类中含有抽象方法，那这个类必须被声明为抽象类，否则编译不通过。

### 方法重写、重载

方法重写：子类中出现了与父类中方法声明一模一样的方法。与返回值类型有关，返回值类型是一致的。

方法重载：本类中出现的方法名相同，参数的种类和数量不同的方法。与返回值类型无关。

**【面试题】方法的重载与重写的区别？**

**重写：**

（前提：在继承的基础之上，子类在获取了父类的结构以后，可以对父类中同名的方法进行“重构”）

方法的返回值，方法名，形参列表形同；权限修饰符不小于父类的同名方法；子类方法的异常类型不大于父类的；

两个方法要同为static或同为非static。

**重载：**

“两同一不同”：同一个类，同一个方法名，不同的参数列表。 注：方法的重载与方法的返回值无关！

\>构造器是可以重载的

没户口会考虑吗，大学期间又什么荣誉，以及读研和老师做的项目

自我介绍+你对枯燥工作的看法+网络/数据库/开发擅长哪个+一个相关问题

我选的数据库没答上来，就问我研究生做啥

什么是事务

问我最有责任感的一件事情

问我的是动态代理，threadlocal，二叉树遍历方式

问了项目时间？还有责任感，自我介绍一分钟以内，以及实习最希望获取到什么

感觉面试官对java和python更熟悉

有没有做过相关的项目，跟着身边的同学视频学习相关的项目。自我介绍的时候提一下

面经：问了研究生阶段的研究方向（无人机，不知道为什么问这个）

抽象类可以有抽象方法吗

抽象类和接口的区别

回答怎么看待加班

# Java集合

### 常见的Java集合有哪些？

Map接口和Collection接口是所有集合框架的父接口：

1. Collection接口的子接口包括：Set接口和List接口
2. Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
3. Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
4. List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

### HashMap与HashTable的区别？

答：

1. HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；
2. HashMap允许K/V都为null；后者K/V都不允许为null；
3. HashMap继承自AbstractMap类；而Hashtable继承自Dictionary类；

### HashMap的底层原理

1. hashmap的底层结构是一个数组，每个数组元素又是链表结构，用于存放ha'sh值相同的key-value对。
2. 但当链表的长度变长后，遍历链表的性能会比较差。
3. JDK 1.8对hashmap作了优化，如果链表的长度超过8，就会把链表转换为红黑树，性能比链表要高。

### **get、set如何实现的**

**set**

1. 首先利用hash函数将key值转换成hash值，
2. 再运用散列法（此处用除法散列法取余），得到需要存入数组的下标index；
3. 得到数组下标后，我们可以将key-value一起存入到数组中。

**get**

先将key值通过hash函数转换成指向内存地址的hash值；

通过equals方法，比较hash值查找对应的内存地址，然后再通过内存地址找到对应的链表，此时再通过equals方法，比较key值是否相等，若相等，取出键值对返回数据，如果不等，沿着链表继续向下寻找比较。

扩容的时候为什么总是取2的n次方：降低碰撞、提高取模的速度，及其原因。

并发条件下使用hashmap会发生什么问题？为什么会发生死循环？扩容时，，,如何解决？contendhashmap, 1.7和1.8的区别？

### 线程池（重点）

怎么使用线程池？

实现了几种线程方案？

3、原子

4、CAS的缺点

# Java多线程

### 什么是进程/线程

一个进程可以有很多线程，每条线程并行执行不同的任务。

不同的进程使用不同的内存空间，而所有的线程共享一片相同的内存空间。

进程在执行时通常拥有独立的内存单元，而线程之间可以共享内存。

### 并发编程三要素

原子性、可见性、有序性

### volatile关键字有什么用途，和Synchronize有什么区别

volatile是一个轻量级的Synchronize，保证了共享变量的可见性，能够防止脏读（读到了修改的数据），

被volatile关键字修饰的变量，如果值发生了改变，其他线程立刻可见

- volatile能保证数据可见性，但是无法保证数据的原子性
- Synchronize既能保证数据可见，也能保证数据原子性

### 并发和并行的区别

- 并发是多个线程同时访问同一资源
- 并行是多件事情同时去做

### **Java**中多线程实现的方式**（四种方法）**

1. 继承Thread类，
2. 实现Runable接口，
3. 实现Callable接口，
4. 通过线程池创建

### Runnable和Callable的区别

1. Callable规定（重写）的方法是call()，Runnable规定（重写）的方法是run()。
2. Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。
3. Call方法可以抛出异常，run方法不可以。

运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。

### Java当中线程状态有哪些

线程状态有 5 种，新建，就绪，运行，阻塞，死亡

### 什么是指令重排序

  指令重排的分类：编译期重排序和运行时重排序

虽然说指令重排可以调高程序的执行效率，但是在多线程环境下运行可能会影响到结果

  解决办法：内存屏障

### 为什么要使用线程池？

创建线程和销毁线程的花销是比较大的，这些时间有可能比处理业务的时间还要长。

这样频繁的创建线程和销毁线程，再加上业务工作线程，消耗系统资源的时间，可能导致系统资源不足。（我们可以把创建和销毁的线程的过程去掉）

### 线程池有什么作用？

1、提高效率 创建好一定数量的线程放在池中，等需要使用的时候就从池中拿一个，这要比需要的时候创建一个线程对象要快的多。

2、方便管理 可以编写线程池管理代码对池中的线程同一进行管理，比如说启动时有该程序创建100个线程，每当有请求的时候，就分配一个线程去工作，如果刚好并发有101个请求，那多出的这一个请求可以排队等候，避免因无休止的创建线程导致系统崩溃。

### 线程池创建方法

https://www.cnblogs.com/lveyHang/p/12060832.html

1. **ThreadPoolExecutor()：原始的创建方法**
2.  **Executors.newFixedThreadPool(int)**

创建一个定长线程池，可控制线程的最大并发数，超出的线程会在队列中等待.

1. **Executors.newSingleThreadExecutor()**       

创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务都按照指定顺序执行。

1. **Executors.newCachedThreadPool()**          创建一个可缓存线程池

### 线程池中的几个重要参数

- corePoolSize：线程池中的常驻核心线程数。
- maximumPoolSize：线程池能够容纳的同时执行的最大线程数，此值大于等于 1。
- keepAliveTime：多余的空闲线程存活时间，当空闲时间达到 keepAliveTime 值时，多余的线程会被销毁，直到只剩下 corePoolSize 个线程为止。
- unit：keepAliveTime 的单位。
- workQueue：任务队列，被提交但尚未被执行的任务。
- threadFactory：表示生成线程池中工作线程的线程工厂，用户创建新线程，一般用默认即可。
- handler：拒绝策略，表示当线程队列满了并且工作线程大于等于线程池的最大线程数(maxnumPoolSize)时如何来拒绝。

### 线程池的底层工作原理

\1. 在创建了线程池后，等待提交过来的任务请求。

\2. 当调用 execute() 方法添加一个请求任务时，线程池会做如下判断：

   2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；

   2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；

   2.3 如果这时候队列满了且正在运行的线程数量还小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；

   2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。

\3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。

\4. 当一个线程无事可做，超过一定的时间(keepAliveTime) 时，线程池会判断：

   如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。

  所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。

**面试详解**

两部分：

Java基础面试题（待完成）

Java高级面试题（如下）

### 并发与并行的区别

并发：多个线程去访问同一个资源

并行：多件事情并行去做

例子：

你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。

并发的关键是你有处理多个任务的能力，不一定要同时。 并行的关键是你有同时处理多个任务的能力。

所以我认为它们最关键的点就是：是否是『同时』。

![img](1-4、Java面试总结zk.assets/587433439395.png)

### volatile

是Java虚拟机提供的**轻量级**的同步机制

### 三大特性：

**1、保证可见性**

volatile关键字可以保证可见性，一个线程改变变量之后，会及时通知其他线程：主物理内存的值已经被修改

**2、不保证原子性**

**原子性**

指的是不可分割、完整性，也即某个线程在做某个业务时，中间不可以被加塞或者被分割，需要整体完成，要么同时成功、同时失败。比如，volatile number; number++（这条语句被拆分成3个指令get、add、put）;

**【重要】number++操作线程不安全**

多个线程执行number++操作时，首先会将number的值从主内存拷贝到各自的工作内存（栈内存），然后在栈内存中对number的副本进行+1操作，最后将副本的值写回主内存。

（1、执行getfield拿到原始值number

​    2、执行iadd进行+1操作

​    3、执行putfield写 把累加后的值写回）

丢失写值的情况：线程1读取number并修改后，准备写回主内存的时候，这时，CPU调度切换，CPU开始执行线程2，线程2执行操作并写回之后，CPU又切换到线程1，这时线程1写入，导致上一次写的值丢失。

- 如何解决原子性

- - 使用sync，但是杀鸡用牛刀了
  - AtomicInteger解决原子性（原理：CAS）

//使用AtomicInteger类型的数据

AtomicInteger atomicInteger = new AtomicInteger();

public void addMyAtomic()

{

atomicInteger.getAndIncrement();

}

**3、禁止指令重排**  

(涉及到happen-bofore原则)

源代码	-》	**编译器优化的重排**	-》	**指令并行的重排**	-》	**内存系统的重排**	-》	最终执行的指令

- 指令重排的原则：

处理器在进行指令重排时，要考虑**数据之间的依赖性**。

不存在数据依赖性的语句，可能会被指令重排。

- 场景

- - 在单线程环境里面，最终执行结果和代码顺序执行的结果一致
  - 多线程环境中，由于线程交替执行，且编译器优化重排的存在，两个线程中使用的变量是否能够保证一致性，是无法确定的。

- volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。

原理：内存屏障（Memory Barrier）

通过插入内存屏障

- - 禁止在内存屏障前后的指令，执行重排序优化；
  - 强制刷新各种CPU的缓存数据，因此任何CPU上的线程都能读到这些数据的最新版本。

写操作+store（强制写到主内存）

load+读操作（从主内存中读）

- 工作内存与主内存同步延迟导致的可见性问题：

使用volatile/synchronized关键字解决，使一个线程修改后的变量立即对其他线程可见

- 对于指令重排导致的可见性与有序性问题：

使用volatile关键字解决，禁止指令重排序

### 你在哪些地方用到过volatile？

**【重要】单例模式（双端检锁+volatile）**

**【不推荐】使用synchronized对方法加锁**

重量级锁

public class SingletonDemo {

  private static SingletonDemo instance = null;

  //构造方法

  private SingletonDemo() {

​    System.out.println(Thread.currentThread().getName() + "\t 构造方法SingletonDemo（）");

 }



  public static synchronized SingletonDemo getInstance() {



​    if (instance == null) {

​      instance = new SingletonDemo();

   }

​    return instance;

 }



  public static void main(String[] args) {

​    //构造方法只会被执行一次

​    //构造方法会在一些情况下执行多次（未加锁）

​    for (int i = 0; i < 10; i++) {

​      new Thread(() -> {

​        SingletonDemo.getInstance();

​     }, "Thread " + i).start();

   }

 }

}

#### 【推荐】DCL

（Double Check Lock）双端检锁机制

#### 存在的问题

不一定线程安全，因为有指令重排的存在，加入volatile可以禁止指令重排。

原因：某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象**可能没有完成初始化**。instance = new SingletonDemo()；可以分为以下3步完成：

- memory = allocate();//1、分配对象的内存空间
- instance(memory);//2、初始化对象
- instance = memory；//3、设置instance指向刚分配的内存地址，直到此时，instance != null

但是步骤2、3不存在数据依赖关系，而且，无论重排不重排，程序的执行结果在单线程中并没有改变，因此，这种重排是允许的。

- memory = allocate();//1、分配对象的内存空间
- instance = memory；//3、设置instance指向刚分配的内存地址，直到此时，instance != null。但是对象还未完成初始化
- instance(memory);//2、初始化对象

但是指令重排只会保证单线程下语句执行的一致性，不保证多线程下语句执行的一致性。

所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。

**解决办法**

设置instance为**volatile类型**

```
public class SingletonDemo {

  private static volatile SingletonDemo instance = null;

  //构造方法

  private SingletonDemo() {

​    System.out.println(Thread.currentThread().getName() + "\t 构造方法SingletonDemo（）");

 }

//不对方法加锁，只对关键代码块加锁，但存在指令重排

  public static SingletonDemo getInstance() {

//在对类加锁前后都要进行判断，判断instance是否为null

​    if (instance == null) {

​      synchronized (SingletonDemo.class) {

​        if (instance == null) {

​          instance = new SingletonDemo();

​       }

​     }

   }

​    return instance;



 }



  public static void main(String[] args) {

​    //构造方法只会被执行一次

​    //构造方法会在一些情况下执行多次

​    for (int i = 0; i < 10; i++) {

​      new Thread(() -> {

​        SingletonDemo.getInstance();

​     }, "Thread " + i).start();

   }

 }

}
```



### 读写锁

### CAS

比较并交换

****JMM****

jvm：Java虚拟机

jmm：Java内存模型，Java memory model

本身是一种抽象的概念，并不真实存在，他描述的一组规范，通过这组规范定义了程序中各个变量（包括实例字段、静态字段和构成数组对象的元素）的访问方式。

### **JMM**关于同步的规定**：**

- 线程解锁前，必须把共享变量的值刷新回主内存
- 线程加锁前，必须读取主内存的最新值到自己的工作内存
- 加锁解锁是同一把锁

### 三大特性

1. 可见性
2. 原子性
3. 有序性

# Java高级

**JAVA基础**

有几种实现多线程的方式（框架），如何设计一个分布式系统

Java中的锁有哪些

### Mysql

事务隔离的方式有哪些

### 什么是反射？

反射是在运行状态中，

对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的对象信息以及动态调用对象的方法的功能

称为Java语言的反射机制。

### 哪里用到反射机制？

JDBC中，利用反射动态加载了数据库驱动程序。

### 反射机制的优缺点？

1. 优点：可以动态执行，在运行期间根据业务功能动态执行方法、访问属性，最大限度发挥了java的灵活性。
2. 缺点：对性能有影响，这类操作总是慢于直接执行java代码。

### 动态代理是什么？有哪些应用？

1. 动态代理是运行时动态生成代理类。
2. 动态代理的应用有 Spring AOP数据查询、测试框架的后端 mock、rpc，Java注解对象获取等。

### 异常

#### 什么是异常？

#### 异常包括哪些类型？

Throwable 是Java定义的所有错误和异常的父类。

Throwable包含两个子类Error 和 Exception。

其中

Error 用来表示 JVM 无法处理的错误，

OutOfMemoryError：内存不足错误；StackOverflowError：栈溢出错误。

此类错误发生时，JVM 将终止线程。

这些错误是不受检异常，非代码性错误。因此，当此类错误发生时，应用程序不应该去处理此类错误。按照Java惯例，我们是不应该实现任何新的Error子类的！

Exception 分为两种：

程序本身可以捕获并且可以处理的异常。

Exception 这种异常又分为两类：运行时异常和编译时异常。

- 运行时异常：RuntimeException 异常会由 Java 虚拟机自动抛出并自动捕获。

包括：NullPointerException空指针异常、ArrayIndexOutBoundException数组下标越	界异常、ClassCastException类型转换异常、ArithmeticExecption算术异常

- 编译时异常：编译器会检查的异常，**该异常我们必须手动在代码里添加捕获语句来处理该异常**。

包括：ClassNotFoundException（没有找到指定的类异常），IOException（IO流异常）

- 受检异常 

编译器要求必须处理的异常。

**除 RuntimeException 及其子类外，其他的 Exception 异常都属于受检异常**。

- 非受检异常 

编译器不会进行检查并且不要求必须处理的异常。

**该类异常包括运行时异常（RuntimeException极其子类）和错误（Error）。**

![img](1-4、Java面试总结zk.assets/ppjwp.png)

### 空指针异常？

#### 什么是空指针异常？

Java 中任何对象都有可能为空，当我们调用空对象的方法时就会抛出 NullPointerException 空指针异常

#### 解决办法？

1、在调用对象的方法前添加一个判断，使用if(对象==null)语句

2、使用Java的静态代码分析工具，如 Eclipse IDE、SpotBugs、Checker Framework 等，它们可以帮助程序员检测出编译期的错误。结合 @Nullable 和 @Nonnull 等注解，我们就可以在程序运行之前发现可能抛出空指针异常的代码。

### 泛型

#### 什么是泛型？

泛型的本质的参数化类型，这种参数类型可以用在类、接口、方法的创建中，分别成为泛型类、泛型接口、泛型方法。

#### 泛型是如何工作的？什么是类型擦除？

泛型是通过类型擦除实现的，编译器在编译时擦除了所有泛型类型相关的信息，所以在运行时不存在泛型任何泛型类型相关的信息。

泛型擦除具体来说就是在编译成字节码时，首先进行类型检查，接着进行类型擦除。（即所有类型参数都是用他们的限定类型）

### 注解

#### 什么是注解？

注解是附加在代码中的一些元信息，起到说明、配置的功能。

注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。

#### 应用场景？

- 编译器的信息 - **使用注解，编译器可以检测错误或抑制警告**
- 编译时和部署时处理 - **软件工具可以处理注解并生成代码，配置文件等。**
- 运行时处理 - **可以在运行时检查注解以自定义程序的行为**

#### 一些注解

@Override -标记方法是否覆盖超类中声明的元素。如果它无法正确覆盖该方法，编译器将发出错误

@Deprecated - 表示该元素已弃用且不应使用。如果程序使用标有此批注的方法，类或字段，编译器将发出警告

# Java数据库

### **有哪些锁**

公平锁、非公平锁、可重入锁、

### **复习**

锁的目的是为了维护数据库的一致性。当多个用户同时访问数据库时，就会出现数据不一致的问题。

### **表锁和行锁**

#### **概念**

**1、表锁**

即使操作一条数据也会锁住整张表，不适合高并发的操作。MyISAM存储引擎就是使用的表锁。

**2、行锁**

操作时只锁某一行，不会对其他行有影响，适合高并发的操作。InnoDB就是使用的行锁。

#### **优缺点**

1. 表级锁：

锁定粒度大，发生锁冲突的概率最高，并发度最低。

但是，加锁快，开销小；不会出现死锁。

1. 行级锁：

锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

但是，加锁慢，开销大；会出现死锁；

1. 页面锁：

锁定粒度界于表锁和行锁之间，并发度一般。会出现死锁。

开销和加锁时间界于表锁和行锁之间；

#### **锁的优化策略**

1. 读写分离

1. 分段加锁

1. 减少锁持有的时间

1. 多个线程尽量以相同的顺序去获取资源

 不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。

### **什么是索引**

**索引是排好序的快速查找数据结构。** 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

### **什么是事务：**

事务是由一组SQL语句组成的逻辑处理单元。

#### **事务的ACID是指什么？**

A：Atomicity原子性

C：Consistent一致性

I：Isolation隔离性

D：Durable持久性

#### **并发事务带来的问题**

1. 更新丢失：

​		当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题。最后的更新覆盖了由其他事务所做的更新。

​		如何避免：一个事务在完成修改/提交数据之前，另一个事务不能访问同一文件，则可避免此问题。

1. 脏读：

​		事务A读到了事务B**已修改但尚未提交**的数据，还在这个数据基础上做了操作。此时。如果事务B回滚，A读取的数据无效，不符合一致性要求。

1. 不可重复读：【MySQL默认的隔离级别】

​		一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了。

​		即：事务A读到了事务B已经提交的修改数据，不符合隔离性。

1. 幻读：

​		一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足查询条件的新数据。

​		即：事务A读取到了事务B提交的新增数据，不符合隔离性。

- 脏读是读到了事务B里面修改的数据；
- 幻读是读到了事务B里面新增的数据；

#### **事务的隔离级别**

数据库必须具备4个特性ACID：原子性、一致性、隔离性、持久性

并发事务导致的4个问题：更新丢失、脏读、不可重读、幻读

**数据库提供的四种隔离级别：** **01：Read uncommitted(读未提交)：最低级别，任何情况都会发生。** **02：Read Committed(读已提交)：可避免脏读的发生。** **03：Repeatable read(可重复读)：可避免脏读、不可重复读的发生。** **04：Serializable(串行化)：避免脏读、不可重复读，幻读的发生。**

#### **注意事项：**

1. 无索引，行锁变表锁；尤其是var类型要加单引号。
2. 间隙锁：间隙锁（Gap Lock）是Innodb在

![img](https://math.jianshu.com/math?formula=%5Ccolor%7Bred%7D%7B%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%7D)

提交下为了解决幻读问题时引入的锁机制。当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙”。

1. 间隙锁的危害：因为Query执行过程中通过范围查找的话，他会锁定整个范围内的所有索引键值，即使这个键值并不存在。而造成在锁定的时候，无法插入锁定键值范围内任何数据，在某些场景下可能会影响性能。
2. 如何锁定一行：

begin;

select * from table_name where a=8 for update;

锁定某一行后，其他操作会被阻塞，直到锁定行的会话提交commit

commit;

### **Mysql数据库**

Mysql的架构可以在不同的场景中应用并发挥良好作用。主要体现在它的存储引擎架构上，**插件式的存储引擎架构**将**查询处理**和**其它的系统任务**以及**数据的存储提取**相分离。这种架构可以根据业务的需要选择合适的存储引擎。

#### **架构**

![img](1-4、Java面试总结zk.assets/6-1180917597.png)

MySQL基架大致包括如下几大模块组件：

#### **一、连接层**

最上层是一些客户端和连接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于tcp/ip 的 通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证 安全接入的客户端提供线程。同样在该层上可以实现基于SSL 的安全链接。服务器也会为安全接入的每个客户端验 证它所具有的操作权限。

**（1）MySQL向外提供的交互接口（Connectors）**

​         Connectors组件，是MySQL向外提供的交互组件，如java,.net,php等语言可以通过该组件来操作SQL语句，实现与SQL的交互。

**（2）连接池组件(Connection Pool)**

​        负责监听对客户端向MySQL Server端的各种请求，接收请求，转发请求到目标模块。每个成功连接MySQL Server的客户请求都会被创建或分配一个线程，该线程负责客户端与MySQL Server端的通信，接收客户端发送的命令，传递服务端的结果信息等。

#### **二、服务层**

**（3）管理服务组件和工具组件(Management Service & Utilities)**

​         系统管理和控制工具

​		提供对MySQL的集成管理，如备份(Backup),恢复(Recovery),安全管理(Security)等

**（4）SQL接口组件(SQL Interface)**

 SQL 接口。接受用户的SQL 命令，并且返回用户需要查询的结果。比如select from 就是调用SQL Interface

​		**接收用户SQL命令**，如DML,DDL和存储过程等，并将最终结果返回给用户。

**（5）解析组件(Parser)**

```
解析器。SQL 命令传递到解析器的时候会被解析器验证和解析
```

​	首先**分析SQL命令**语法的合法性，并尝试将SQL命令分解成数据结构，若分解失败，则提示SQL语句不合理。

**（6）优化器组件（Optimizer）**

查询优化器。SQL 语句在查询之前会使用查询优化器对查询进行优化，比如有where 条件时，优化器来决定先投影还是先过滤。

 对SQL命令按照标准流程进行优化分析。

**（7）缓存主件（Caches & Buffers）**

查询缓存。

如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key 缓存，权限缓存等

#### **三、引擎层**

**（8）MySQL存储引擎**

  存储引擎层，存储引擎真正的负责了MySQL 中数据的存储和提取，服务器通过API 与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。

#### **四、存储层**

数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。

**关于存储引擎**

**MyISAM与InnoDB**

![img](1-4、Java面试总结zk.assets/586484121723.png)

![img](D:\Program\Youdao\YNoteData\weixinobU7VjttUaQpmMx2t56gFqBfm2gQ\ca7cbf0cb5db404992702ca238d80cdf\586484381782.png)

**aliSQL**

Perconac产品：主要功能XtraDB存储引擎（可以完全代替innoDB），提升了高负载情况下的InnoDB的性能、为DBA提供了一些非常有用的性能诊断工具。性能和并发上做的更好。

### **常用命令大全**

查看数据库的事务隔离级别，默认<可重复读>

```
show variables like 'tx_isolation';
```

关闭自动提交

```
set autocommit=0;
```

分析系统中行锁的情况

```
show status like 'innodb_row_lock%';
```

#### **profile**

查看sql的执行周期

```
show variables like '%profiling%'
```

查看最近的几次查询

```
show profile
```

根据查询id查看某次查询的具体消耗

```
show profile cpu,block io for query Query_id
```

show engines:查看所有的数据库引擎

```
show variables like '%storage_engine%' 查看默认的数据库引擎
```

#### **join**

![img](1-4、Java面试总结zk.assets/586484455139.png)

on后面＋连接的条件；where后面＋过滤的条件

**内连接**

select <select_list> from tableA A **inner join** tableB B **on** A.Key = B.key

**左连接**

select <select_list> from A  **left join** B **on** A.Key = B.key

**左连接（不要AB的共有）**

select <select_list> from A  **left join** B **on** A.Key = B.key **where** B.Key=null

**全外连接**

select <select_list> from A **FULL OUTER JOIN** B **on** A.Key = B.key

select <select_list> from A **left join** B **on** A.Key = B.key



#### union

select <select_list> from A **right join** B **on** A.Key = B.key

**注意mysql不支持full  outer join，使用union命令拼接左连接+右连接（union语句执行时自动去重）**

**index**

create index idx_user_name on user(name)

show index from table_name



#### **lock**

**mysql的读写锁有什么区别：**

读锁会阻塞写，但不会阻塞读；而写锁会把读和写都阻塞。

show open tables;

上锁(给mylock表上读锁，给book表上写锁):

读锁是共享锁，其他用户都可以读select,但是任何用户都不能修改。

lock table mylock read, book write;

解锁

unlock tables;



表锁：偏向Myisam存储引擎

分析系统上的表锁定（检查table_locks_waited、table_locks_immediate变量）

show status like 'table%';

table_locks_waited：出现表级锁定争用而发生等待的次数，此值较高说明存在较严重的表级锁争用情况

table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每次立即获得锁，此字段+1



行锁：偏向Innodb存储引擎（与Myisam的不同：支持事务、支持行锁）



### **性能下降的原因**

- 查询语句写的烂
- 索引失效
- 关联查询写的join太多
- 服务器调优及各个参数设置（缓冲、线程数等）

### **SQL的执行顺序**

语句的执行过程

mysql 的查询流程大致是： mysql 客户端通过协议与mysql 服务器建连接，发送查询语句，先检查查询缓存，如果命中，直接返回结果， 否则进行语句解析,也就是说，在解析查询之前，服务器会先访问查询缓存(query cache)——它存储SELECT 语句以及相应的查询结果集。如果某个查询结果已经位于缓存中，服务器就不会再对查询进行解析、优化、以及执行。它仅仅将缓存中的结果返回给用户即可，这将大大提高系统的性能。 语法解析器和预处理：首先mysql 通过关键字将SQL 语句进行解析，并生成一颗对应的“解析树”。mysql 解析 器将使用mysql 语法规则验证和解析查询；预处理器则根据一些mysql 规则进一步检查解析数是否合法。 查询优化器当解析树被认为是合法的了，并且由优化器将其转化成执行计划。一条查询可以有很多种执行方式， 最后都返回相同的结果。优化器的作用就是找到这其中最好的执行计划。。 然后，mysql 默认使用的BTREE 索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql 最多只 用到表中的一个索引。

#### **手写的顺序：**

![img](1-4、Java面试总结zk.assets/586484935275.png)

#### **真正执行的顺序：**

随着Mysql 版本的更新换代，其优化器也在不断的升级，优化器会分析不同执行顺序产生的性能消耗不同而动 态调整执行顺序。下面是经常出现的查询顺序：

#### **机读从From开始**

![img](1-4、Java面试总结zk.assets/586484987067.png)

![img](1-4、Java面试总结zk.assets/586485033405.png)

### **索引**

MySQL 官方对索引的定义为：索引（Index）是帮助MySQL 高效获取数据的数据结构。可以得到索引的本质： 索引是数据结构。可以简单理解为

**索引是排好序的快速查找数据结构。** 在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

**优缺点 (查找快、增删慢)**

#### **优势：**

1. 提高数据**检索**的效率，降低数据库的**IO**成本。
2. 通过索引列对数据进行**排序**，降低数据排序（Order By）的成本，降低了**CPU**的消耗。

#### **劣势：**

1. 虽然索引大大提高了查询速度，同时却会**降低更新表的速度**，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
2. 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要**占用空间** 的。

#### **思考：**

**1、为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？**

**1) B+树的磁盘读写代价更低** B+树的内部结点并没有指向关键字具体信息的指针。因此其**内部结点相对B 树更小**。

​	如果把所有同一内部结点的关键字	存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。

​	**一次性读入内存中的需要查找的关键字也就越多**。相对来说**IO 读写次数也就降低**了。 **2) B+树的查询效率更加稳定** 	由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。

​	任何关键字的查找必须走一条从根结点到叶子结点的路。

​	所有关键字查询的路径长度相同，导致**每一个数据的查询效率相当**。

**2、B树与B+树的区别？**

B树

![img](1-4、Java面试总结zk.assets/586488858040.png)

![img](1-4、Java面试总结zk.assets/586488882952.png)

B+树